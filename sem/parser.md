# Необходимое чтение

1. http://redis.io/topics/protocol

# Представление значений из протокола

Запрос или ответ в протоколе redis представляет из себя одно
"значение". Значение может быть числом, строкой или массивом других
значений. Если бы мы писали на динамическом языке, то у нас не
возникло бы проблем с этим, но C++ - статически типизированный, и
переменная в нем не может быть одновременно строкой или числом. В С мы
решали бы эту проблему с помощью union, но в union можно хранить
только примитивные типы, а мы хотим засунуть туда объект с
конструктором и деструктором (вектор например).

Можно было бы решить проблему примерно так:

    ```
    struct RedisValue {
        enum { INT, STR, ARR } type;

        int i;
        std::string s;
        std::vector<RedisValue> a;
    }
    ```

Но такой подход не очень надежен (можно обратиться к строке, когда
по смыслу у нас число), и не очень удобен в использовании (нужно
писать кучу конструкторов, либо каждый раз заполнять руками поля
структуры).

Мы будем пользоваться библиотекой boost/variant (пакет boost-dev-all
на ubuntu). Variant - это контейнер, содержащий не более одного
объекта одного из заданных типов. Более подробнее читайте
документацию, нам нужно знать только:

  1. variant можно конструировать из конкретного типа.
  2. Можно узнать тип объекта, хранящегося в variant с помощью value.which().
  3. Можно доставать конкретный тип из variant с помощью boost::get<T>(value).

# Reader и Writer, буферизованый ввод-вывод.

Чтобы писать парсер, нам нужен буферизованный ввод-вывод. Можно
попробовать использовать std::istream и std::ostream, но они не
предоставляют достаточного контроля (попробуйте прочитать строку "$a b
c\r\n", так чтобы читалась только эта строка и никакая другая). Кроме
того, стандартные классы не умеют читать из сокета.

Мы будем писать собственный буферизированный ввод-вывод. В проекте
уже есть классы Reader и Writer. Общая схема их работы похожа.

В классе Writer есть буфер, с которым функции чтения работают
напрямую. Когда буфер переполняется, вызывается виртуальная функция,
которая должна этот буфер записать куда-то и очистить.

Таким образом, Writer можно научить писать в сокет или файл,
переопределив всего один виртуальный метод.

Writer работает аналогично, там метод read_more() должен считать
следующую пачку данных, когда текущий буфер полностью обработан.

# Парсер и сериализатор

Имея в распоряжении классы Reader и Writer можно написать
преобразование из RedisValue в строку и обратно.

    ```
    void WriteRedisValue(Writer* w, const RedisValue& value);
    void ReadRedisValue(Reader* r, RedisValue* value);
    ```

В примере уже есть преобразование для числа, нужно добавить
преобразование для всех остальных типов(см описание протокола).

# Тесты

Сначала нужно прочитать https://code.google.com/p/googletest/wiki/Primer

Функции WriteRedisValue и ReadRedisValue должны быть
протестированны. В test/redis_test.cpp уже есть примеры того как это
делать.

В тестах используются наследники классов Writer и Reader, которые
пишут/читают в строку, а не в сокет. Если бы мы тестировали парсер на
реальном TCP соединении, то 1) тесты работали бы дольше, 2) их сложнее
было бы писать, 3) они работали бы ненадежно.

# Что делать дальше?

1. Разобраться с тем как работает boost/variant.
2. Прочитать введение в gtest.
3. Добавить остальные типы в WriteRedisValue.
4. Протестировать эту функцию.
5. Добавить остальные типы в ReadRedisValue.
6. Протестировать парсер на входных данных.
7. Протестировать парсер на некорректных входных данных.
